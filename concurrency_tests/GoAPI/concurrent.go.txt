// package main

// import (
// 	"context"
// 	"database/sql"
// 	"encoding/json"
// 	"log"
// 	"net/http"
// 	"sync"
// 	"time"

// 	"github.com/google/uuid"
// 	_ "github.com/lib/pq"
// )

// var (
// 	db         *sql.DB
// 	cache      = make(map[string][]Manga)
// 	cacheMutex sync.RWMutex
// 	cacheTime  time.Time
// )

// type Manga struct {
// 	ID               uuid.UUID      `json:"id"`
// 	Title            sql.NullString `json:"title"`
// 	Description      sql.NullString `json:"description"`
// 	OriginalLanguage sql.NullString `json:"original_language"`
// 	LastVolume       sql.NullString `json:"last_volume"`
// 	LastChapter      sql.NullString `json:"last_chapter"`
// 	Demographic      sql.NullString `json:"demographic"`
// 	Status           sql.NullString `json:"status"`
// 	Year             sql.NullInt64  `json:"year"`
// 	ContentRating    sql.NullString `json:"content_rating"`
// 	State            sql.NullString `json:"state"`
// 	IsLocked         sql.NullBool   `json:"is_locked"`
// 	ChapterReset     sql.NullBool   `json:"chapter_reset"`
// 	CreatedAt        sql.NullTime   `json:"created_at"`
// 	UpdatedAt        sql.NullTime   `json:"updated_at"`
// 	Version          sql.NullInt64  `json:"version"`
// }

// // init connection to the database
// func init() {
// 	connection_string := "postgres://postgres:password@localhost:5432/postgres?sslmode=disable"

// 	var err error
// 	db, err = sql.Open("postgres", connection_string)
// 	if err != nil {
// 		log.Fatal("Failed to open database: ", err)
// 	}

// 	// Optimize connection pool settings
// 	db.SetMaxOpenConns(50) // Increased for better concurrent handling
// 	db.SetMaxIdleConns(10) // Keep more idle connections
// 	db.SetConnMaxLifetime(time.Minute * 3)
// 	db.SetConnMaxIdleTime(time.Minute) // Add idle timeout

// 	if err := db.Ping(); err != nil {
// 		log.Fatal("Failed to ping database:", err)
// 	}
// }

// func getMangaFromDB(ctx context.Context) ([]Manga, error) {
// 	rows, err := db.QueryContext(ctx, "SELECT * FROM manga")
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer rows.Close()

// 	var mangas []Manga
// 	for rows.Next() {
// 		var manga Manga
// 		err := rows.Scan(
// 			&manga.ID,
// 			&manga.Title,
// 			&manga.Description,
// 			&manga.OriginalLanguage,
// 			&manga.LastVolume,
// 			&manga.LastChapter,
// 			&manga.Demographic,
// 			&manga.Status,
// 			&manga.Year,
// 			&manga.ContentRating,
// 			&manga.State,
// 			&manga.IsLocked,
// 			&manga.ChapterReset,
// 			&manga.CreatedAt,
// 			&manga.UpdatedAt,
// 			&manga.Version,
// 		)
// 		if err != nil {
// 			return nil, err
// 		}
// 		mangas = append(mangas, manga)
// 	}
// 	return mangas, rows.Err()
// }

// func getCachedManga(ctx context.Context) ([]Manga, error) {
// 	cacheMutex.RLock()
// 	if time.Since(cacheTime) < time.Minute && len(cache) > 0 {
// 		defer cacheMutex.RUnlock()
// 		return cache["manga"], nil
// 	}
// 	cacheMutex.RUnlock()

// 	// If cache is expired or empty, refresh it
// 	cacheMutex.Lock()
// 	defer cacheMutex.Unlock()

// 	// Double-check pattern
// 	if time.Since(cacheTime) < time.Minute && len(cache) > 0 {
// 		return cache["manga"], nil
// 	}

// 	mangas, err := getMangaFromDB(ctx)
// 	if err != nil {
// 		return nil, err
// 	}

// 	cache["manga"] = mangas
// 	cacheTime = time.Now()
// 	return mangas, nil
// }

// func getAllManga(w http.ResponseWriter, r *http.Request) {
// 	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
// 	defer cancel()

// 	mangas, err := getCachedManga(ctx)
// 	if err != nil {
// 		log.Printf("Error fetching manga: %v", err)
// 		http.Error(w, "Error fetching data", http.StatusInternalServerError)
// 		return
// 	}

// 	w.Header().Set("Content-Type", "application/json")
// 	if err := json.NewEncoder(w).Encode(mangas); err != nil {
// 		log.Printf("Error encoding JSON: %v", err)
// 		http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
// 		return
// 	}
// }

// func main() {
// 	// Create a custom server with timeouts
// 	server := &http.Server{
// 		Addr:           ":5000",
// 		Handler:        http.HandlerFunc(getAllManga),
// 		ReadTimeout:    10 * time.Second,
// 		WriteTimeout:   10 * time.Second,
// 		MaxHeaderBytes: 1 << 20,
// 	}

// 	log.Println("Starting server on :5000")
// 	if err := server.ListenAndServe(); err != nil {
// 		log.Fatal("Error starting server: ", err)
// 	}
// }
